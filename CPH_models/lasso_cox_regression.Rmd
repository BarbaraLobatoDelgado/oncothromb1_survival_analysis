---
title: "Lasso Cox Regression"
author: "Bárbara Lobato Delgado"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Settings and load libraries

```{r}
# Deactivate scientific notation
options(scipen = 999, max.print = 10000)

# Seed
seed = 2828
set.seed(seed)
```


```{r}
find_column_mismatch <- function(df1, df2) {
  # Find column mismatch
  missing_in_valid <- setdiff(colnames(df1), colnames(df2))
  extra_in_valid <- setdiff(colnames(df2), colnames(df1))
  
  if (length(missing_in_valid) > 0 || length(extra_in_valid) > 0) {
    msg <- c()
    if (length(missing_in_valid) > 0) {
      msg <- c(msg, sprintf("Columns missing in validation: %s", 
                            paste(missing_in_valid, collapse = ", ")))
    }
    if (length(extra_in_valid) > 0) {
      msg <- c(msg, sprintf("Extra columns in validation: %s",
                          paste(extra_in_valid, collapse = ", ")))
    }
    stop(paste(msg, collapse = "; "), call. = FALSE)
  }
}
```


```{r}
# Load libraries
pacman::p_load(
  # kfoldsableExtra,
  an9elproject, 
  tidyverse,
  lubridate, 
  magrittr,
  fastDummies,
  glmnet,
  survival,
  survminer, 
  powerSurvEpi,
  car,
  StepReg,
  plotly,
  install = FALSE, update = FALSE
  )
```

## Load data

```{r cars}
# Load time-dependent dataset
oncoth1_td_dataset = read.csv(file = "/mnt/ir-bioinf02/home/blobato/oncothromb01/data/processed/oncoth1_td_dataset.csv")
```


```{r}
# Remove columns with missing values
oncoth1_td_dataset %<>%
  select(where(~ !any(is.na(.))))

# Stop if there are missing values in dataset
stopifnot(!anyNA(oncoth1_td_dataset))
```


```{r}
# Get meaningful variables
oncoth1_td_dataset_selected_vars <- oncoth1_td_dataset %>%
  select(vte_event,
         age_when_cancer_dx, 
         gender, 
         bmi_value, 
         performance_status_category_corrected_imp, 
         diabetes_mellitus,
         dyslipidemia, 
         arterial_hypertension, 
         tobacco_use_imp, 
         copd_imp, 
         venous_insufficiency_imp, 
         khorana_risk_score_imp, 
         two_groups_krs,
         previous_onco_surgery,
         tumor_surgically_removed, 
         primary_tumor_simplified, 
         tnm_stage_grouped, 
         tnm_stage_two_groups, 
         histology_type_imp,
         mucinous_histology_imp,
         grade_histological_differentiation_imp,
         catheter_device_imp, 
         family_background_vte, 
         previous_vte,  
         previous_ate, 
         anticoag_tx_currently, 
         antiaggreg_tx_currently)
```

```{r}
# # Train your model on the training fold
# model = StepReg::stepwiseCox(
#   formula = Surv(time = tstart, time2 = tstop, event = death) ~
#   vte_event +
#   age_when_cancer_dx +
#   gender +
#   bmi_value +
#   performance_status_category_corrected_imp + # Multicollinearity with cancer type, tobacco use, tumor resection in some folds, but models can be trained
#   # diabetes_mellitus + # Confounder. We kfoldsnow it is associated with pancreatic cancer patients that undergo resection of pancreas
#   dyslipidemia +
#   # tobacco_use_imp + # Correlated to NSCLC. Multicollinearity if PS is also selected
#   # copd_imp + # Correlated to tobacco use
#   arterial_hypertension +
#   # venous_insufficiency_imp +  # remove as suggested by Andrés Muñoz (bad definition of variable, information may refer to different conditions)
#   # kfoldshorana_riskfolds_score_imp + # Correlated to pancreatic and esophago-gastric cancers
#   # two_groups_kfoldsrs + # Correlated to pancreatic and esophago-gastric cancers
#   # previous_onco_surgery + # Correlated to having had tumor resected
#   tumor_surgically_removed +
#   primary_tumor_simplified +
#   # tnm_stage_grouped +
#   tnm_stage_two_groups +
#   # histology_type_imp + # Correlated with NSCLC
#   mucinous_histology_imp +
#   # grade_histological_differentiation_imp + # violates PH assumption
#   # catheter_device_imp + # quite correlated with tumor type, as Cramer's V indicates
#   # family_backfoldsground_vte + # High GVIF, multicollinearity with venous insufficiency in some folds. When selected, not clear if it is riskfolds or protective factor, due to lackfolds of information when recruiting patients
#   previous_vte +
#   previous_ate +
#   anticoag_tx_currently +
#   antiaggreg_tx_currently,
#   data = training_fold,
#   include = "primary_tumor_simplified",
#   selection = "bidirection",
#   select = "AIC",
#   method = "efron"
#   )
```



```{r}
# Change name of dependent variable
oncoth1_td_data_clean <- dummy_cols(
  .data = oncoth1_td_dataset_selected_vars, 
  select_columns = NULL, 
  remove_first_dummy = TRUE, 
  remove_selected_columns = TRUE
  )
oncoth1_td_data_clean
```


```{r}
# Transform covariates dataframe into matrix
covariates <- as.matrix(oncoth1_td_data_clean)
# Scale 
covariates_scaled <- scale(covariates)
```


```{r}
# Create response Surv() object
# Allow for right-censoring to handle time-dependent variables
response = with(oncoth1_td_dataset, Surv(tstart, tstop, death))
response[1:5]
```

```{r}
# Covariates matrix and response must have same length (number of patients)
stopifnot(dim(covariates)[0] == length(response))
```


```{r}
library(penalized)

fit <- penalized(
  response    = response, 
  penalized  = covariates_scaled,
  unpenalized = ~1,
  lambda1     = 10,        # your LASSO penalty
  model       = "cox"
)

```

```{r}
coef(fit)
```


```{r}
cols2select <- c(
 "vte_event",
 "age_when_cancer_dx", 
 "gender", 
 "bmi_value", 
 "performance_status_category_corrected_imp", 
 "diabetes_mellitus",
 "dyslipidemia", 
 "arterial_hypertension", 
 "tobacco_use_imp", 
 "copd_imp", 
 "venous_insufficiency_imp", 
 "khorana_risk_score_imp", 
 "two_groups_krs",
 "previous_onco_surgery",
 "tumor_surgically_removed", 
 "primary_tumor_simplified", 
 # "tnm_stage_grouped", 
 "tnm_stage_two_groups", 
 # "histology_type_imp", # unequal categories between train and validation set
 "mucinous_histology_imp",
 "grade_histological_differentiation_imp",
 "catheter_device_imp", 
 "family_background_vte", 
 "previous_vte",  
 "previous_ate", 
 # "anticoag_tx_currently", # unequal categories between train and validation set
 "antiaggreg_tx_currently"
 )
```


```{r}
process_data <- function(data, cols2select) {
  
  missing_cols <- setdiff(cols2select, colnames(data))
  if (length(missing_cols) > 0) {
    stop(paste("The following columns are missing from the data:", 
               paste(missing_cols, collapse = ", ")))
  }
  
  # Select columns as dependent variables
  data_selection <- data[, cols2select]
  
  # Convert yes/no columns into 1/0
  data_selection <- data_selection %>%
    mutate(
      across(
        .cols = where(~ (is.character(.) || is.factor(.)) && 
                        all(as.character(.) %in% c("Yes", "No"))), 
        .fns = ~ as.integer(as.character(.) == "Yes")
      )
    )
  
  # Convert categorical to numeric
  data_dummies <- dummy_cols(
    .data = data_selection, 
    select_columns = NULL, 
    remove_first_dummy = TRUE, 
    remove_selected_columns = TRUE
    )
  
  # Transform covariates dataframe into matrix
  covariates <- as.matrix(data_dummies)
  # Scale 
  covariates_scaled <- scale(covariates)
  
  # # Create response Surv() object
  # # Allow for right-censoring to handle time-dependent variables
  # response = with(data, Surv(tstart, tstop, death))
  
  # return(list("covariates_scaled" = covariates_scaled, "response" = response))
  return(covariates_scaled)
}
```

```{r}
# process_data(oncoth1_td_dataset, cols2select)
```


## Dataset partition

```{r}
# Partition data with repeated rows per patient into training and test set

# Get unique IDs
unique_ids <- unique(oncoth1_td_dataset$id)

# Randomly assign each unique ID to either train or test
train_ids <- sample(unique_ids, size = floor(0.8 * length(unique_ids))) # 80% for training
test_ids <- setdiff(unique_ids, train_ids)  # Remaining IDs for testing

# # Get rows of train and test patients
# train_rows <- which(oncoth1_td_dataset$id %in% train_ids)
# test_rows <- which(oncoth1_td_dataset$id %in% test_ids)
# 
# # Partition data keeping the IDs (needed for stratified CV)
# training_set_with_ids <- oncoth1_td_dataset %>% 
#   filter(id %in% train_ids) %>% 
#   select(id)
# testing_set_with_ids <- oncoth1_td_dataset %>% 
#   filter(id %in% test_ids) %>%
#   select(id)

# Partition data
training_set <- oncoth1_td_dataset %>% filter(id %in% train_ids)
test_set <- oncoth1_td_dataset %>% filter(id %in% test_ids)
# training_set <- oncoth1_td_dataset[train_rows,]
# test_set <- oncoth1_td_dataset[test_rows,]
# training_set <- covariates[train_rows,]
# test_set <- covariates[test_rows,]

# # Partition response
# training_response <- response[train_rows,]
# test_response <- response[test_rows,]

# Surv response for full data
response = with(oncoth1_td_dataset, Surv(tstart, tstop, death))
train_rows <- which(oncoth1_td_dataset$id %in% train_ids)
test_rows <- which(oncoth1_td_dataset$id %in% test_ids)
# Get response for training and test sets
training_response <- response[train_rows]
test_response <- response[test_rows]

# Check that all patients are accounted for in training and test set
stopifnot(dim(training_set)[0] + dim(test_set)[0] == covariates)
stopifnot(length(training_response) + length(test_response) == length(response))
```


```{r}
# # Partition the data into train and test sets based on the assigned IDs
# training_set <- oncoth1_td_dataset %>% filter(id %in% train_ids)
# testing_set <- oncoth1_td_dataset %>% filter(id %in% test_ids)
# 
# # Checkfolds that IDs are not in training and test sets
# stopifnot(
#   identical(
#     sort(unique(training_set$id)), sort(unique(testing_set$id))) == FALSE)
```


```{r}
# Create folds for k-fold CV

# Number of folds
kfolds <- 10

# # Create a grouping variable for each ID
# group_var <- as.numeric(factor(oncoth1_td_dataset$id))
unique_train_ids <- unique(train_ids)

# Determine the unique IDs and shuffle them randomly to ensure a balanced distribution across the folds
# Get unique IDs
# folds_unique_ids <- unique(group_var)

# # Shuffle the unique IDs randomly
# folds_shuffled_ids <- sample(folds_unique_ids)
# 
# # Divide the shuffled IDs into folds
# cv_folds_index <- cut(folds_shuffled_ids, breaks = kfolds, labels = FALSE)

# Shuffle and assign
shuffled_train_ids <- sample(unique_train_ids)
# Get size for each fold
fold_sizes <- floor(length(shuffled_train_ids) / kfolds)
remainder <- length(shuffled_train_ids) %% kfolds

fold_vec <- rep(
  1:kfolds, 
  times = c(rep(fold_sizes + 1, remainder), 
            rep(fold_sizes, kfolds - remainder))
)

# Map each ID to each fold
fold_map <- data.frame(
  patient_id = shuffled_train_ids,
  fold = fold_vec
)

```






```{r}
# Cross-validation loop
set.seed(seed)

# Store resutls
cv_cindex <- numeric(kfolds)
cv_selected_vars <- vector("list", kfolds)

for (i in seq_len(kfolds)) {
  # Determine training and validation patient IDs
  validation_ids <- fold_map$patient_id[fold_map$fold == i]
  training_ids <- setdiff(unique_train_ids, validation_ids)
  
  # Subset interval-level data
  valid_data <- training_set %>% filter(id %in% validation_ids)
  train_data <- training_set %>% filter(id %in% training_ids)
  
  # Sanity checks
  stopifnot(
    setequal(validation_ids, unique(valid_data$id)),
    setequal(training_ids, unique(train_data$id))
  )
  
  # Process data
  X_valid <- process_data(valid_data, cols2select)
  X_train <- process_data(train_data, cols2select)
  
  # Find column mismatch if there is one
  find_column_mismatch(X_valid, X_train)
  
  # Get responses
  y_valid <- with(valid_data, Surv(tstart, tstop, death))
  y_train <- with(train_data, Surv(tstart, tstop, death))
  
  # Fit penalized Cox on training fold
  fit_cv <- penalized(
    response = y_train,
    penalized = X_train,
    unpenalized = ~1, 
    lambda1 = 10,
    lambda2 = 0.1,
    model = "cox"
  )
  
  # Evaluate using C-index
  pred_valid <- penalized::predict(
    object = fit_cv, 
    penalized = X_valid
    )
  print(pred_valid)
  # cv_cindex[i] <- survConcordance(y_valid ~ pred_valid)$concordance
  # 
  # # Record selected variables
  # coefs <- coef(fit_cv)
  # cv_selected_vars[[i]] <- names(coefs)[which(coefs != 0)]
  # 
  # message(sprintf(
  #   "Fold %d: C-index = %.3f; Selected %d vars", 
  #   i, 
  #   cv_index[i], 
  #   length(cv_selected_vars[[i]])
  # ))
  
}
```






```{r}
# Initialize a vector to store the evaluation results
cv_index_valid <- vector("list", length = kfolds)
cv_vars_results <- vector("list", length = kfolds)
cv_cindex_results <- vector("list", length = kfolds)
cv_vif_results <- vector("list", length = kfolds) # Inspection of GVIF in trained models is necessary to detect multicollinearity issues

for (i in 1:kfolds) {       # each i is the number of a fold
  # Get the validation IDs
  validation_ids <- unique_ids[cv_folds_index == i]
  print(validation_ids)
  
  # Get the validation fold
  valid_data <- training_set[training_set_with_ids$id %in% validation_ids, ]
  print(unique(valid_data$id))
  # stopifnot(all(validation_ids == unique(valid_data$id)))
  stopifnot(
  setequal(validation_ids, unique(valid_data$id)),
  length(validation_ids) == length(unique(valid_data$id))
  )
  
  
  
  y_valid <- with(valid_data, Surv(tstart, tstop, death))
  valid_data <- process_data(valid_data, cols2select)
  # valid <- transformed_data[0]
  # valid_response <- transformed_data[1]
  
  
  
  # y_valid <- training_response[training_set_with_ids$id %in% validation_ids]
  # # Scale data
  # valid <- scale(valid)
  # print(valid)
  
  # # Separate target from data
  # y_valid <- y_training
  # valid <- valid %>% select(-death)
  
  # Get the training fold
  train_data <- training_set[!(training_set_with_ids$id %in% validation_ids), ]
  # # Scale data
  # tr <- scale(tr)
  
  # # Separate target from data
  # y_training_fold <- training_fold$death
  # training_fold <- training_fold %>% select(-death)
  
  # print("Training")
  # print(head(training_fold, n = kfolds))
  # 
  # print("Validation")
  # print(head(valid, n = kfolds))
  
  # # Check dimensions
  # stopifnot(dim(tr)[0] + dim(train_data)[0] == dim(valid_data)[0])
  
  # # Checkfolds that IDs are not in training and test sets
  # stopifnot(
  #   identical(
  #     sort(unique(training_fold$id)), sort(unique(valid$id))) == FALSE)
}
  
  # # Lasso Cox regression
  # cvfit <- cv.glmnet(
  #   x = training_fold,
  #   y = y_training_fold,
  #   family = "cox", 
  #   alpha = 1 # alpha = 1 is Lasso, 0 is ridge. In between, elastic net
  # )
  # 
  # print(cvfit)
  
  # # lambda_star <- cvfit$lambda.min
  # fit_lasso <- glmnet(
  #   x = training_fold,
  #   y = y_training_fold, 
  #   family = "cox",
  #   alpha = 1,
  #   lambda = lambda_star
  # )
  # 
  # print(fit_lasso)
  # 
  # lp_val <- predict(
  #   fit_lasso,
  #   newx = valid
  # )
  
  
  
  
  # # Train your model on the training fold
  # model = StepReg::stepwiseCox(
  #   formula = Surv(time = tstart, time2 = tstop, event = death) ~
  #   vte_event +
  #   age_when_cancer_dx +
  #   gender +
  #   bmi_value +
  #   performance_status_category_corrected_imp + # Multicollinearity with cancer type, tobacco use, tumor resection in some folds, but models can be trained
  #   # diabetes_mellitus + # Confounder. We kfoldsnow it is associated with pancreatic cancer patients that undergo resection of pancreas
  #   dyslipidemia +
  #   # tobacco_use_imp + # Correlated to NSCLC. Multicollinearity if PS is also selected
  #   # copd_imp + # Correlated to tobacco use
  #   arterial_hypertension +
  #   # venous_insufficiency_imp +  # remove as suggested by Andrés Muñoz (bad definition of variable, information may refer to different conditions)
  #   # kfoldshorana_riskfolds_score_imp + # Correlated to pancreatic and esophago-gastric cancers
  #   # two_groups_kfoldsrs + # Correlated to pancreatic and esophago-gastric cancers
  #   # previous_onco_surgery + # Correlated to having had tumor resected
  #   tumor_surgically_removed + 
  #   primary_tumor_simplified +
  #   # tnm_stage_grouped +
  #   tnm_stage_two_groups +
  #   # histology_type_imp + # Correlated with NSCLC
  #   mucinous_histology_imp +
  #   # grade_histological_differentiation_imp + # violates PH assumption
  #   # catheter_device_imp + # quite correlated with tumor type, as Cramer's V indicates
  #   # family_backfoldsground_vte + # High GVIF, multicollinearity with venous insufficiency in some folds. When selected, not clear if it is riskfolds or protective factor, due to lackfolds of information when recruiting patients
  #   previous_vte +
  #   previous_ate +
  #   anticoag_tx_currently +
  #   antiaggreg_tx_currently, 
  #   data = training_fold,
  #   include = "primary_tumor_simplified",
  #   selection = "bidirection",
  #   select = "AIC", 
  #   method = "efron"
  #   )
  
  # # Save selected variables
  # selected_variables = unname(unlist(model$`Selected Varaibles`))
  # # print(selected_variables)
  # 
  # # Fit model with selected variables in this fold
  # # Create formula
  # fold_pcox_formula = as.formula(
  #   sprintf('%s ~ %s', 'Surv(time = tstart, time2 = tstop, event = death)',
  #           paste(selected_variables, collapse = " + ")))
  # 
  # # Fit model
  # fold_cph_model = coxph(
  #   formula = fold_pcox_formula, 
  #   id = id,
  #   data = valid
  # )
  # 
  # # VIF
  # vif_results = rms::vif(fold_cph_model)
  # # print(vif_results)
  # 
  # # Makfoldse predictions on the validation fold
  # # The result is the hazard of suffering the event. It's difficult to interpret
  # predictions <- predict(fold_cph_model, newdata = valid)
  # # print(predictions)
  # 
  # # Evaluate the predictions
  # # C-index
  # fold_cindex <- concordance(fold_cph_model, newdata = valid)
  # # print(fold_cindex$concordance)
  # 
  # # Store the evaluation result
  # cv_index_valid[[i]] = validation_ids
  # cv_vars_results[[i]] = selected_variables
  # cv_cindex_results[[i]] = fold_cindex$concordance
  # cv_vif_results[[i]] = as.data.frame(vif_results)

```





