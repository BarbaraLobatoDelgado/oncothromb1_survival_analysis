---
title: "Lasso Cox Regression"
author: "Bárbara Lobato Delgado"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Settings and load libraries

```{r}
# Deactivate scientific notation
options(scipen = 999, max.print = 10000)

# Seed
seed = 2828
set.seed(seed)
```


```{r}
# Load libraries
pacman::p_load(
  # kfoldsableExtra,
  an9elproject, 
  tidyverse,
  lubridate, 
  magrittr,
  fastDummies,
  glmnet,
  survival,
  survminer, 
  powerSurvEpi,
  car,
  StepReg,
  plotly,
  install = FALSE, update = FALSE
  )
```

## Load data

```{r cars}
# Load time-dependent dataset
oncoth1_td_dataset = read.csv(file = "/mnt/ir-bioinf02/home/blobato/oncothromb01/data/processed/oncoth1_td_dataset.csv")
```


```{r}
# Remove columns with missing values
oncoth1_td_dataset %<>%
  select(where(~ !any(is.na(.))))

# Stop if there are missing values in dataset
stopifnot(!anyNA(oncoth1_td_dataset))
```


```{r}
# Get meaningful variables
oncoth1_td_dataset_selected_vars <- oncoth1_td_dataset %>%
  select(vte_event,
         age_when_cancer_dx, 
         gender, 
         bmi_value, 
         performance_status_category_corrected_imp, 
         diabetes_mellitus,
         dyslipidemia, 
         arterial_hypertension, 
         tobacco_use_imp, 
         copd_imp, 
         venous_insufficiency_imp, 
         khorana_risk_score_imp, 
         two_groups_krs,
         previous_onco_surgery,
         tumor_surgically_removed, 
         primary_tumor_simplified, 
         tnm_stage_grouped, 
         tnm_stage_two_groups, 
         histology_type_imp,
         mucinous_histology_imp,
         grade_histological_differentiation_imp,
         catheter_device_imp, 
         family_background_vte, 
         previous_vte,  
         previous_ate, 
         anticoag_tx_currently, 
         antiaggreg_tx_currently)
```

```{r}
# # Train your model on the training fold
# model = StepReg::stepwiseCox(
#   formula = Surv(time = tstart, time2 = tstop, event = death) ~
#   vte_event +
#   age_when_cancer_dx +
#   gender +
#   bmi_value +
#   performance_status_category_corrected_imp + # Multicollinearity with cancer type, tobacco use, tumor resection in some folds, but models can be trained
#   # diabetes_mellitus + # Confounder. We kfoldsnow it is associated with pancreatic cancer patients that undergo resection of pancreas
#   dyslipidemia +
#   # tobacco_use_imp + # Correlated to NSCLC. Multicollinearity if PS is also selected
#   # copd_imp + # Correlated to tobacco use
#   arterial_hypertension +
#   # venous_insufficiency_imp +  # remove as suggested by Andrés Muñoz (bad definition of variable, information may refer to different conditions)
#   # kfoldshorana_riskfolds_score_imp + # Correlated to pancreatic and esophago-gastric cancers
#   # two_groups_kfoldsrs + # Correlated to pancreatic and esophago-gastric cancers
#   # previous_onco_surgery + # Correlated to having had tumor resected
#   tumor_surgically_removed +
#   primary_tumor_simplified +
#   # tnm_stage_grouped +
#   tnm_stage_two_groups +
#   # histology_type_imp + # Correlated with NSCLC
#   mucinous_histology_imp +
#   # grade_histological_differentiation_imp + # violates PH assumption
#   # catheter_device_imp + # quite correlated with tumor type, as Cramer's V indicates
#   # family_backfoldsground_vte + # High GVIF, multicollinearity with venous insufficiency in some folds. When selected, not clear if it is riskfolds or protective factor, due to lackfolds of information when recruiting patients
#   previous_vte +
#   previous_ate +
#   anticoag_tx_currently +
#   antiaggreg_tx_currently,
#   data = training_fold,
#   include = "primary_tumor_simplified",
#   selection = "bidirection",
#   select = "AIC",
#   method = "efron"
#   )
```



```{r}
# Change name of dependent variable
oncoth1_td_data_clean <- dummy_cols(
  .data = oncoth1_td_dataset_selected_vars, 
  select_columns = NULL, 
  remove_first_dummy = TRUE, 
  remove_selected_columns = TRUE
  )
oncoth1_td_data_clean
```


```{r}
# Transform covariates dataframe into matrix
covariates <- as.matrix(oncoth1_td_data_clean)
# Scale 
covariates_scaled <- scale(covariates)
```


```{r}
# Create response Surv() object
# Allow for right-censoring to handle time-dependent variables
response = with(oncoth1_td_dataset, Surv(tstart, tstop, death))
response[1:5]
```

```{r}
# Covariates matrix and response must have same length (number of patients)
stopifnot(dim(covariates)[0] == length(response))
```


```{r}
library(penalized)

fit <- penalized(
  response    = response, 
  penalized  = covariates_scaled,
  unpenalized = ~1,
  lambda1     = 10,        # your LASSO penalty
  model       = "cox"
)

```

```{r}
coef(fit)
```


```{r}
cols2select <- c("vte_event",
         "age_when_cancer_dx", 
         "gender", 
         "bmi_value", 
         "performance_status_category_corrected_imp", 
         "diabetes_mellitus",
         "dyslipidemia", 
         "arterial_hypertension", 
         "tobacco_use_imp", 
         "copd_imp", 
         "venous_insufficiency_imp", 
         "khorana_risk_score_imp", 
         "two_groups_krs",
         "previous_onco_surgery",
         "tumor_surgically_removed", 
         "primary_tumor_simplified", 
         "tnm_stage_grouped", 
         "tnm_stage_two_groups", 
         "histology_type_imp",
         "mucinous_histology_imp",
         "grade_histological_differentiation_imp",
         "catheter_device_imp", 
         "family_background_vte", 
         "previous_vte",  
         "previous_ate", 
         "anticoag_tx_currently", 
         "antiaggreg_tx_currently")
```


```{r}
process_data <- function(data, cols2select) {
  
  missing_cols <- setdiff(cols2select, colnames(data))
  if (length(missing_cols) > 0) {
    stop(paste("The following columns are missing from the data:", 
               paste(missing_cols, collapse = ", ")))
  }
  
  # Select columns as dependent variables
  data_selection <- data[, cols2select]
  
  # Convert categorical to numeric
  data_dummies <- dummy_cols(
    .data = data_selection, 
    select_columns = NULL, 
    remove_first_dummy = TRUE, 
    remove_selected_columns = TRUE
    )
  
  # Transform covariates dataframe into matrix
  covariates <- as.matrix(data_dummies)
  # Scale 
  covariates_scaled <- scale(covariates)
  
  # # Create response Surv() object
  # # Allow for right-censoring to handle time-dependent variables
  # response = with(data, Surv(tstart, tstop, death))
  
  # return(list("covariates_scaled" = covariates_scaled, "response" = response))
  return(covariates_scaled)
}
```



## Dataset partition

```{r}
# Partition data with repeated rows per patient into training and test set

# Get unique IDs
unique_ids <- unique(oncoth1_td_dataset$id)

# Randomly assign each unique ID to either train or test
train_ids <- sample(unique_ids, size = floor(0.8 * length(unique_ids))) # 80% for training
test_ids <- setdiff(unique_ids, train_ids)  # Remaining IDs for testing

# Get rows of train and test patients
train_rows <- which(oncoth1_td_dataset$id %in% train_ids)
test_rows <- which(oncoth1_td_dataset$id %in% test_ids)

# Partition data keeping the IDs (needed for stratified CV)
training_set_with_ids <- oncoth1_td_dataset %>% 
  filter(id %in% train_ids) %>% 
  select(id)
testing_set_with_ids <- oncoth1_td_dataset %>% 
  filter(id %in% test_ids) %>%
  select(id)

# Partition data
training_set <- oncoth1_td_dataset[train_rows,]
test_set <- oncoth1_td_dataset[test_rows,]
# training_set <- covariates[train_rows,]
# test_set <- covariates[test_rows,]

# Partition response
training_response <- response[train_rows,]
test_response <- response[test_rows,]

# Check that all patients are accounted for in training and test set
stopifnot(dim(training_set)[0] + dim(test_set)[0] == covariates)
stopifnot(length(training_response) + length(test_response) == length(response))
```


```{r}
# # Partition the data into train and test sets based on the assigned IDs
# training_set <- oncoth1_td_dataset %>% filter(id %in% train_ids)
# testing_set <- oncoth1_td_dataset %>% filter(id %in% test_ids)
# 
# # Checkfolds that IDs are not in training and test sets
# stopifnot(
#   identical(
#     sort(unique(training_set$id)), sort(unique(testing_set$id))) == FALSE)
```


```{r}
# Set number of folds 
kfolds = 10

# Initialize a vector to store the evaluation results
cv_index_valid <- vector("list", length = kfolds)
cv_vars_results <- vector("list", length = kfolds)
cv_cindex_results <- vector("list", length = kfolds)
cv_vif_results <- vector("list", length = kfolds) # Inspection of GVIF in trained models is necessary to detect multicollinearity issues

for (i in 1:kfolds) {       # each i is the number of a fold
  # Get the validation IDs
  validation_ids <- unique_ids[cv_folds_index == i]
  
  # Get the validation fold
  valid_data <- training_set[training_set_with_ids$id %in% validation_ids, ]
  y_valid <- with(valid_data, Surv(tstart, tstop, death))
  valid_data <- process_data(valid_data, cols2select)
  # valid <- transformed_data[0]
  # valid_response <- transformed_data[1]
  
  
  
  # y_valid <- training_response[training_set_with_ids$id %in% validation_ids]
  # # Scale data
  # valid <- scale(valid)
  # print(valid)
  
  # # Separate target from data
  # y_valid <- y_training
  # valid <- valid %>% select(-death)
  
  # Get the training fold
  tr <- training_set[!(training_set_with_ids$id %in% validation_ids), ]
  # Scale data
  tr <- scale(training_fold)
  
  # # Separate target from data
  # y_training_fold <- training_fold$death
  # training_fold <- training_fold %>% select(-death)
  
  # print("Training")
  # print(head(training_fold, n = kfolds))
  # 
  # print("Validation")
  # print(head(valid, n = kfolds))
  
  # Check dimensions
  stopifnot(dim(training_fold)[0] + dim(valid)[0] == dim(training_set)[0])
  
  # # Checkfolds that IDs are not in training and test sets
  # stopifnot(
  #   identical(
  #     sort(unique(training_fold$id)), sort(unique(valid$id))) == FALSE)
}
  
  # # Lasso Cox regression
  # cvfit <- cv.glmnet(
  #   x = training_fold,
  #   y = y_training_fold,
  #   family = "cox", 
  #   alpha = 1 # alpha = 1 is Lasso, 0 is ridge. In between, elastic net
  # )
  # 
  # print(cvfit)
  
  # lambda_star <- cvfit$lambda.min
  fit_lasso <- glmnet(
    x = training_fold,
    y = y_training_fold, 
    family = "cox",
    alpha = 1,
    lambda = lambda_star
  )
  
  print(fit_lasso)
  
  lp_val <- predict(
    fit_lasso,
    newx = valid
  )
  
  
  
  
  # # Train your model on the training fold
  # model = StepReg::stepwiseCox(
  #   formula = Surv(time = tstart, time2 = tstop, event = death) ~
  #   vte_event +
  #   age_when_cancer_dx +
  #   gender +
  #   bmi_value +
  #   performance_status_category_corrected_imp + # Multicollinearity with cancer type, tobacco use, tumor resection in some folds, but models can be trained
  #   # diabetes_mellitus + # Confounder. We kfoldsnow it is associated with pancreatic cancer patients that undergo resection of pancreas
  #   dyslipidemia +
  #   # tobacco_use_imp + # Correlated to NSCLC. Multicollinearity if PS is also selected
  #   # copd_imp + # Correlated to tobacco use
  #   arterial_hypertension +
  #   # venous_insufficiency_imp +  # remove as suggested by Andrés Muñoz (bad definition of variable, information may refer to different conditions)
  #   # kfoldshorana_riskfolds_score_imp + # Correlated to pancreatic and esophago-gastric cancers
  #   # two_groups_kfoldsrs + # Correlated to pancreatic and esophago-gastric cancers
  #   # previous_onco_surgery + # Correlated to having had tumor resected
  #   tumor_surgically_removed + 
  #   primary_tumor_simplified +
  #   # tnm_stage_grouped +
  #   tnm_stage_two_groups +
  #   # histology_type_imp + # Correlated with NSCLC
  #   mucinous_histology_imp +
  #   # grade_histological_differentiation_imp + # violates PH assumption
  #   # catheter_device_imp + # quite correlated with tumor type, as Cramer's V indicates
  #   # family_backfoldsground_vte + # High GVIF, multicollinearity with venous insufficiency in some folds. When selected, not clear if it is riskfolds or protective factor, due to lackfolds of information when recruiting patients
  #   previous_vte +
  #   previous_ate +
  #   anticoag_tx_currently +
  #   antiaggreg_tx_currently, 
  #   data = training_fold,
  #   include = "primary_tumor_simplified",
  #   selection = "bidirection",
  #   select = "AIC", 
  #   method = "efron"
  #   )
  
  # # Save selected variables
  # selected_variables = unname(unlist(model$`Selected Varaibles`))
  # # print(selected_variables)
  # 
  # # Fit model with selected variables in this fold
  # # Create formula
  # fold_pcox_formula = as.formula(
  #   sprintf('%s ~ %s', 'Surv(time = tstart, time2 = tstop, event = death)',
  #           paste(selected_variables, collapse = " + ")))
  # 
  # # Fit model
  # fold_cph_model = coxph(
  #   formula = fold_pcox_formula, 
  #   id = id,
  #   data = valid
  # )
  # 
  # # VIF
  # vif_results = rms::vif(fold_cph_model)
  # # print(vif_results)
  # 
  # # Makfoldse predictions on the validation fold
  # # The result is the hazard of suffering the event. It's difficult to interpret
  # predictions <- predict(fold_cph_model, newdata = valid)
  # # print(predictions)
  # 
  # # Evaluate the predictions
  # # C-index
  # fold_cindex <- concordance(fold_cph_model, newdata = valid)
  # # print(fold_cindex$concordance)
  # 
  # # Store the evaluation result
  # cv_index_valid[[i]] = validation_ids
  # cv_vars_results[[i]] = selected_variables
  # cv_cindex_results[[i]] = fold_cindex$concordance
  # cv_vif_results[[i]] = as.data.frame(vif_results)

}
```





